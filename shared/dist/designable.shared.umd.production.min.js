(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Designable = global.Designable || {}, global.Designable.Shared = {})));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    var isType = function (type) {
        return function (obj) {
            return obj != null &&
                (Array.isArray(type) ? type : [type]).some(function (t) { return getType(obj) === "[object ".concat(t, "]"); });
        };
    };
    var getType = function (obj) { return Object.prototype.toString.call(obj); };
    var isFn = isType([
        'Function',
        'AsyncFunction',
        'GeneratorFunction',
    ]);
    var isWindow = isType('Window');
    var isHTMLElement = function (obj) {
        return (obj === null || obj === void 0 ? void 0 : obj['nodeName']) || (obj === null || obj === void 0 ? void 0 : obj['tagName']);
    };
    var isArr = Array.isArray;
    var isPlainObj = isType('Object');
    var isStr = isType('String');
    var isBool = isType('Boolean');
    var isNum = isType('Number');
    var isObj = function (val) { return typeof val === 'object'; };
    var isRegExp = isType('RegExp');
    var isValid = function (val) { return val !== null && val !== undefined; };
    var isValidNumber = function (val) {
        return !isNaN(val) && isNum(val);
    };

    var UNSUBSCRIBE_ID_SYMBOL = Symbol('UNSUBSCRIBE_ID_SYMBOL');
    var Subscribable = /** @class */ (function () {
        function Subscribable() {
            var _this = this;
            this.subscribers = {
                index: 0,
            };
            this.unsubscribe = function (id) {
                if (id === undefined || id === null) {
                    for (var key in _this.subscribers) {
                        _this.unsubscribe(key);
                    }
                    return;
                }
                if (!isFn(id)) {
                    delete _this.subscribers[id];
                }
                else {
                    delete _this.subscribers[id[UNSUBSCRIBE_ID_SYMBOL]];
                }
            };
        }
        Subscribable.prototype.dispatch = function (event, context) {
            var interrupted = false;
            for (var key in this.subscribers) {
                if (isFn(this.subscribers[key])) {
                    event['context'] = context;
                    if (this.subscribers[key](event) === false) {
                        interrupted = true;
                    }
                }
            }
            return interrupted ? false : true;
        };
        Subscribable.prototype.subscribe = function (subscriber) {
            var _this = this;
            var id;
            if (isFn(subscriber)) {
                id = this.subscribers.index + 1;
                this.subscribers[id] = subscriber;
                this.subscribers.index++;
            }
            var unsubscribe = function () {
                _this.unsubscribe(id);
            };
            unsubscribe[UNSUBSCRIBE_ID_SYMBOL] = id;
            return unsubscribe;
        };
        return Subscribable;
    }());

    function getGlobalThis() {
        try {
            if (typeof self !== 'undefined') {
                return self;
            }
        }
        catch (e) { }
        try {
            if (typeof globalThisPolyfill !== 'undefined') {
                return globalThisPolyfill;
            }
        }
        catch (e) { }
        try {
            if (typeof global !== 'undefined') {
                return global;
            }
        }
        catch (e) { }
        return Function('return this')();
    }
    var globalThisPolyfill = getGlobalThis();

    var ATTACHED_SYMBOL = Symbol('ATTACHED_SYMBOL');
    var EVENTS_SYMBOL = Symbol('__EVENTS_SYMBOL__');
    var EVENTS_ONCE_SYMBOL = Symbol('EVENTS_ONCE_SYMBOL');
    var EVENTS_BATCH_SYMBOL = Symbol('EVENTS_BATCH_SYMBOL');
    var DRIVER_INSTANCES_SYMBOL = Symbol('DRIVER_INSTANCES_SYMBOL');
    var isOnlyMode = function (mode) {
        return mode === 'onlyOne' || mode === 'onlyChild' || mode === 'onlyParent';
    };
    /**
     * 事件驱动器基类
     */
    var EventDriver = /** @class */ (function () {
        function EventDriver(engine, context) {
            this.container = document;
            this.contentWindow = globalThisPolyfill;
            this.engine = engine;
            this.context = context;
        }
        EventDriver.prototype.dispatch = function (event) {
            return this.engine.dispatch(event, this.context);
        };
        EventDriver.prototype.subscribe = function (subscriber) {
            return this.engine.subscribe(subscriber);
        };
        EventDriver.prototype.subscribeTo = function (type, subscriber) {
            return this.engine.subscribeTo(type, subscriber);
        };
        EventDriver.prototype.subscribeWith = function (type, subscriber) {
            return this.engine.subscribeWith(type, subscriber);
        };
        EventDriver.prototype.attach = function (container) {
            console.error('attach must implement.');
        };
        EventDriver.prototype.detach = function (container) {
            console.error('attach must implement.');
        };
        EventDriver.prototype.eventTarget = function (type) {
            var _a;
            if (type === 'resize' || type === 'scroll') {
                if (this.container === ((_a = this.contentWindow) === null || _a === void 0 ? void 0 : _a.document)) {
                    return this.contentWindow;
                }
            }
            return this.container;
        };
        EventDriver.prototype.addEventListener = function (type, listener, options) {
            var _a, _b, _c, _d;
            var target = this.eventTarget(type);
            if (isOnlyMode(options === null || options === void 0 ? void 0 : options.mode)) {
                target[EVENTS_ONCE_SYMBOL] = target[EVENTS_ONCE_SYMBOL] || {};
                var constructor = this['constructor'];
                constructor[EVENTS_ONCE_SYMBOL] = constructor[EVENTS_ONCE_SYMBOL] || {};
                var handler = target[EVENTS_ONCE_SYMBOL][type];
                var container = constructor[EVENTS_ONCE_SYMBOL][type];
                if (!handler) {
                    if (container) {
                        if (options.mode === 'onlyChild') {
                            if (container.contains(target)) {
                                container.removeEventListener(type, container[EVENTS_ONCE_SYMBOL][type], options);
                                delete container[EVENTS_ONCE_SYMBOL][type];
                            }
                        }
                        else if (options.mode === 'onlyParent') {
                            if (container.contains(target))
                                return;
                        }
                    }
                    target.addEventListener(type, listener, options);
                    target[EVENTS_ONCE_SYMBOL][type] = listener;
                    constructor[EVENTS_ONCE_SYMBOL][type] = target;
                }
            }
            else {
                target[EVENTS_SYMBOL] = target[EVENTS_SYMBOL] || {};
                target[EVENTS_SYMBOL][type] = target[EVENTS_SYMBOL][type] || new Map();
                if (!((_b = (_a = target[EVENTS_SYMBOL][type]) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, listener))) {
                    target.addEventListener(type, listener, options);
                    (_d = (_c = target[EVENTS_SYMBOL][type]) === null || _c === void 0 ? void 0 : _c.set) === null || _d === void 0 ? void 0 : _d.call(_c, listener, true);
                }
            }
        };
        EventDriver.prototype.removeEventListener = function (type, listener, options) {
            var _a, _b;
            var target = this.eventTarget(type);
            if (isOnlyMode(options === null || options === void 0 ? void 0 : options.mode)) {
                var constructor = this['constructor'];
                constructor[EVENTS_ONCE_SYMBOL] = constructor[EVENTS_ONCE_SYMBOL] || {};
                target[EVENTS_ONCE_SYMBOL] = target[EVENTS_ONCE_SYMBOL] || {};
                delete constructor[EVENTS_ONCE_SYMBOL][type];
                delete target[EVENTS_ONCE_SYMBOL][type];
                target.removeEventListener(type, listener, options);
            }
            else {
                target[EVENTS_SYMBOL] = target[EVENTS_SYMBOL] || {};
                target[EVENTS_SYMBOL][type] = target[EVENTS_SYMBOL][type] || new Map();
                (_b = (_a = target[EVENTS_SYMBOL][type]) === null || _a === void 0 ? void 0 : _a.delete) === null || _b === void 0 ? void 0 : _b.call(_a, listener);
                target.removeEventListener(type, listener, options);
            }
        };
        EventDriver.prototype.batchAddEventListener = function (type, listener, options) {
            this.engine[DRIVER_INSTANCES_SYMBOL] =
                this.engine[DRIVER_INSTANCES_SYMBOL] || [];
            if (!this.engine[DRIVER_INSTANCES_SYMBOL].includes(this)) {
                this.engine[DRIVER_INSTANCES_SYMBOL].push(this);
            }
            this.engine[DRIVER_INSTANCES_SYMBOL].forEach(function (driver) {
                var target = driver.eventTarget(type);
                target[EVENTS_BATCH_SYMBOL] = target[EVENTS_BATCH_SYMBOL] || {};
                if (!target[EVENTS_BATCH_SYMBOL][type]) {
                    target.addEventListener(type, listener, options);
                    target[EVENTS_BATCH_SYMBOL][type] = listener;
                }
            });
        };
        EventDriver.prototype.batchRemoveEventListener = function (type, listener, options) {
            this.engine[DRIVER_INSTANCES_SYMBOL] =
                this.engine[DRIVER_INSTANCES_SYMBOL] || [];
            this.engine[DRIVER_INSTANCES_SYMBOL].forEach(function (driver) {
                var target = driver.eventTarget(type);
                target[EVENTS_BATCH_SYMBOL] = target[EVENTS_BATCH_SYMBOL] || {};
                target.removeEventListener(type, listener, options);
                delete target[EVENTS_BATCH_SYMBOL][type];
            });
        };
        return EventDriver;
    }());
    /**
     * 事件引擎
     */
    var Event = /** @class */ (function (_super) {
        __extends(Event, _super);
        function Event(props) {
            var _this = _super.call(this) || this;
            _this.drivers = [];
            _this.containers = [];
            if (isArr(props === null || props === void 0 ? void 0 : props.effects)) {
                props.effects.forEach(function (plugin) {
                    plugin(_this);
                });
            }
            if (isArr(props === null || props === void 0 ? void 0 : props.drivers)) {
                _this.drivers = props.drivers;
            }
            return _this;
        }
        Event.prototype.subscribeTo = function (type, subscriber) {
            return this.subscribe(function (event) {
                if (type && event instanceof type) {
                    return subscriber(event);
                }
            });
        };
        Event.prototype.subscribeWith = function (type, subscriber) {
            return this.subscribe(function (event) {
                if (isArr(type)) {
                    if (type.includes(event === null || event === void 0 ? void 0 : event.type)) {
                        return subscriber(event);
                    }
                }
                else {
                    if (type && (event === null || event === void 0 ? void 0 : event.type) === type) {
                        return subscriber(event);
                    }
                }
            });
        };
        Event.prototype.attachEvents = function (container, contentWindow, context) {
            var _this = this;
            if (contentWindow === void 0) { contentWindow = globalThisPolyfill; }
            if (!container)
                return;
            if (isWindow(container)) {
                return this.attachEvents(container.document, container, context);
            }
            if (container[ATTACHED_SYMBOL])
                return;
            container[ATTACHED_SYMBOL] = this.drivers.map(function (EventDriver) {
                var driver = new EventDriver(_this, context);
                driver.contentWindow = contentWindow;
                driver.container = container;
                driver.attach(container);
                return driver;
            });
            if (!this.containers.includes(container)) {
                this.containers.push(container);
            }
        };
        Event.prototype.detachEvents = function (container) {
            var _this = this;
            if (!container) {
                this.containers.forEach(function (container) {
                    _this.detachEvents(container);
                });
                return;
            }
            if (isWindow(container)) {
                return this.detachEvents(container.document);
            }
            if (!container[ATTACHED_SYMBOL])
                return;
            container[ATTACHED_SYMBOL].forEach(function (driver) {
                driver.detach(container);
            });
            this[DRIVER_INSTANCES_SYMBOL] = this[DRIVER_INSTANCES_SYMBOL] || [];
            this[DRIVER_INSTANCES_SYMBOL] = this[DRIVER_INSTANCES_SYMBOL].reduce(function (drivers, driver) {
                if (driver.container === container) {
                    driver.detach(container);
                    return drivers;
                }
                return drivers.concat(driver);
            }, []);
            this.containers = this.containers.filter(function (item) { return item !== container; });
            delete container[ATTACHED_SYMBOL];
            delete container[EVENTS_SYMBOL];
            delete container[EVENTS_ONCE_SYMBOL];
            delete container[EVENTS_BATCH_SYMBOL];
        };
        return Event;
    }(Subscribable));

    var createUniformSpeedAnimation = function (speed, callback) {
        if (speed === void 0) { speed = 10; }
        var request = null;
        var startTime = null;
        var start = function () {
            if (request)
                return;
            request = requestAnimationFrame(function (timestamp) {
                if (startTime === null) {
                    startTime = timestamp;
                }
                var deltaTime = timestamp - startTime;
                var delta = (deltaTime / 1000) * speed;
                callback(delta);
                request = null;
                start();
            });
        };
        start();
        return function () {
            if (request) {
                cancelAnimationFrame(request);
                request = null;
            }
            startTime = null;
        };
    };
    //越接近阈值，速度越小，越远离阈值，速度越大
    var calcSpeedFactor = function (delta, threshold) {
        if (delta === void 0) { delta = 0; }
        if (threshold === void 0) { threshold = Infinity; }
        if (threshold >= delta) {
            return (threshold - delta) / threshold;
        }
        return 0;
    };

    var MAX_SPEED = 80; // px/s
    var calcAutoScrollBasicInfo = function (point, axis, viewport, maxSpeed) {
        if (maxSpeed === void 0) { maxSpeed = MAX_SPEED; }
        var left = viewport.left, right = viewport.right, top = viewport.top, bottom = viewport.bottom;
        var x = point.x, y = point.y;
        var begin;
        var end;
        var pos;
        var speedFactor;
        if (axis === 'x') {
            begin = left;
            end = right;
            pos = x;
        }
        else {
            begin = top;
            end = bottom;
            pos = y;
        }
        var scrollerSize = end - begin;
        var moveDistance = scrollerSize > 400 ? 100 : scrollerSize / 3;
        if (end - pos < moveDistance) {
            return {
                direction: 'end',
                speedFactor: speedFactor,
                speed: maxSpeed * calcSpeedFactor(end - pos, moveDistance),
            };
        }
        else if (pos - begin < moveDistance) {
            return {
                direction: 'begin',
                speedFactor: speedFactor,
                speed: maxSpeed * calcSpeedFactor(pos - begin, moveDistance),
            };
        }
        return null;
    };
    var updateScrollValue = function (element, axis, value, callback) {
        if (element) {
            if (!isWindow(element)) {
                if (axis === 'x') {
                    if (element.scrollLeft + value > element.scrollWidth)
                        return;
                    element.scrollLeft += value;
                    if (isFn(callback)) {
                        callback(element.scrollLeft);
                    }
                }
                else {
                    if (element.scrollTop + value > element.scrollHeight)
                        return;
                    element.scrollTop += value;
                    if (isFn(callback)) {
                        callback(element.scrollTop);
                    }
                }
            }
            else {
                if (axis === 'x') {
                    element.scrollBy({
                        left: value,
                        behavior: 'smooth',
                    });
                }
                else {
                    element.scrollBy({
                        top: value,
                        behavior: 'smooth',
                    });
                }
                if (isFn(callback)) {
                    callback(value);
                }
            }
        }
    };
    var scrollAnimate = function (element, axis, direction, speed, callback) {
        return createUniformSpeedAnimation(speed, function (delta) {
            updateScrollValue(element, axis, direction === 'begin' ? 0 - delta : delta, callback);
        });
    };

    function isRect(rect) {
        return (rect === null || rect === void 0 ? void 0 : rect.x) && (rect === null || rect === void 0 ? void 0 : rect.y) && (rect === null || rect === void 0 ? void 0 : rect.width) && (rect === null || rect === void 0 ? void 0 : rect.height);
    }
    function isPoint(val) {
        return isValidNumber(val === null || val === void 0 ? void 0 : val.x) && isValidNumber(val === null || val === void 0 ? void 0 : val.y);
    }
    function isLineSegment(val) {
        return isPoint(val === null || val === void 0 ? void 0 : val.start) && isPoint(val === null || val === void 0 ? void 0 : val.end);
    }
    var Point = /** @class */ (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        return Point;
    }());
    var Rect = /** @class */ (function () {
        function Rect(x, y, width, height) {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        Object.defineProperty(Rect.prototype, "left", {
            get: function () {
                return this.x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Rect.prototype, "right", {
            get: function () {
                return this.x + this.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Rect.prototype, "top", {
            get: function () {
                return this.y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Rect.prototype, "bottom", {
            get: function () {
                return this.y + this.height;
            },
            enumerable: false,
            configurable: true
        });
        return Rect;
    }());
    var LineSegment = /** @class */ (function () {
        function LineSegment(start, end) {
            this.start = __assign({}, start);
            this.end = __assign({}, end);
        }
        return LineSegment;
    }());
    exports.RectQuadrant = void 0;
    (function (RectQuadrant) {
        RectQuadrant["Inner1"] = "I1";
        RectQuadrant["Inner2"] = "I2";
        RectQuadrant["Inner3"] = "I3";
        RectQuadrant["Inner4"] = "I4";
        RectQuadrant["Outer1"] = "O1";
        RectQuadrant["Outer2"] = "O2";
        RectQuadrant["Outer3"] = "O3";
        RectQuadrant["Outer4"] = "O4";
    })(exports.RectQuadrant || (exports.RectQuadrant = {}));
    function isPointInRect(point, rect, sensitive) {
        if (sensitive === void 0) { sensitive = true; }
        var boundSensor = function (value) {
            if (!sensitive)
                return 0;
            var sensor = value * 0.1;
            if (sensor > 20)
                return 20;
            if (sensor < 10)
                return 10;
            return sensor;
        };
        return (point.x >= rect.x + boundSensor(rect.width) &&
            point.x <= rect.x + rect.width - boundSensor(rect.width) &&
            point.y >= rect.y + boundSensor(rect.height) &&
            point.y <= rect.y + rect.height - boundSensor(rect.height));
    }
    function isEqualRect(target, source) {
        return ((target === null || target === void 0 ? void 0 : target.x) === (source === null || source === void 0 ? void 0 : source.x) &&
            target.y === source.y &&
            target.width === source.width &&
            target.height === source.height);
    }
    function getRectPoints(source) {
        var p1 = new Point(source.x, source.y);
        var p2 = new Point(source.x + source.width, source.y);
        var p3 = new Point(source.x + source.width, source.y + source.height);
        var p4 = new Point(source.x, source.y + source.height);
        return [p1, p2, p3, p4];
    }
    function isRectInRect(target, source) {
        var _a = __read(getRectPoints(target), 4), p1 = _a[0], p2 = _a[1], p3 = _a[2], p4 = _a[3];
        return (isPointInRect(p1, source, false) &&
            isPointInRect(p2, source, false) &&
            isPointInRect(p3, source, false) &&
            isPointInRect(p4, source, false));
    }
    function isCrossRectInRect(target, source) {
        var targetCenterPoint = new Point(target.x + target.width / 2, target.y + target.height / 2);
        var sourceCenterPoint = new Point(source.x + source.width / 2, source.y + source.height / 2);
        return (Math.abs(targetCenterPoint.x - sourceCenterPoint.x) <=
            target.width / 2 + source.width / 2 &&
            Math.abs(targetCenterPoint.y - sourceCenterPoint.y) <=
                target.height / 2 + source.height / 2);
    }
    /**
     * 计算点在矩形的哪个象限
     * @param point
     * @param rect
     */
    function calcQuadrantOfPointToRect(point, rect) {
        var isInner = isPointInRect(point, rect);
        if (point.x <= rect.x + rect.width / 2) {
            if (point.y <= rect.y + rect.height / 2) {
                if (isInner) {
                    return exports.RectQuadrant.Inner1;
                }
                else {
                    return exports.RectQuadrant.Outer1;
                }
            }
            else {
                if (isInner) {
                    return exports.RectQuadrant.Inner4;
                }
                else {
                    return exports.RectQuadrant.Outer4;
                }
            }
        }
        else {
            if (point.y <= rect.y + rect.height / 2) {
                if (isInner) {
                    return exports.RectQuadrant.Inner2;
                }
                else {
                    return exports.RectQuadrant.Outer2;
                }
            }
            else {
                if (isInner) {
                    return exports.RectQuadrant.Inner3;
                }
                else {
                    return exports.RectQuadrant.Outer3;
                }
            }
        }
    }
    function calcDistanceOfPointToRect(point, rect) {
        var minX = Math.min(Math.abs(point.x - rect.x), Math.abs(point.x - (rect.x + rect.width)));
        var minY = Math.min(Math.abs(point.y - rect.y), Math.abs(point.y - (rect.y + rect.height)));
        if (point.x >= rect.x && point.x <= rect.x + rect.width) {
            minX = 0;
        }
        if (point.y >= rect.y && point.y <= rect.y + rect.height) {
            minY = 0;
        }
        return Math.sqrt(Math.pow(minX, 2) + Math.pow(minY, 2));
    }
    function calcDistancePointToEdge(point, rect) {
        var distanceTop = Math.abs(point.y - rect.y);
        var distanceBottom = Math.abs(point.y - (rect.y + rect.height));
        var distanceLeft = Math.abs(point.x - rect.x);
        var distanceRight = Math.abs(point.x - (rect.x + rect.width));
        return Math.min(distanceTop, distanceBottom, distanceLeft, distanceRight);
    }
    function isNearAfter(point, rect, inline) {
        if (inline === void 0) { inline = false; }
        if (inline) {
            return (Math.abs(point.x - rect.x) + Math.abs(point.y - rect.y) >
                Math.abs(point.x - (rect.x + rect.width)) +
                    Math.abs(point.y - (rect.y + rect.height)));
        }
        return Math.abs(point.y - rect.y) > Math.abs(point.y - (rect.y + rect.height));
    }
    /**
     * 计算点鱼矩形的相对位置信息
     * @param point
     * @param rect
     */
    function calcRelativeOfPointToRect(point, rect) {
        var distance = calcDistanceOfPointToRect(point, rect);
        var quadrant = calcQuadrantOfPointToRect(point, rect);
        return {
            quadrant: quadrant,
            distance: distance,
        };
    }
    function calcBoundingRect(rects) {
        if (!(rects === null || rects === void 0 ? void 0 : rects.length))
            return;
        if ((rects === null || rects === void 0 ? void 0 : rects.length) === 1 && !rects[0])
            return;
        var minTop = Infinity;
        var maxBottom = -Infinity;
        var minLeft = Infinity;
        var maxRight = -Infinity;
        rects.forEach(function (item) {
            var rect = new Rect(item.x, item.y, item.width, item.height);
            if (rect.top <= minTop) {
                minTop = rect.top;
            }
            if (rect.bottom >= maxBottom) {
                maxBottom = rect.bottom;
            }
            if (rect.left <= minLeft) {
                minLeft = rect.left;
            }
            if (rect.right >= maxRight) {
                maxRight = rect.right;
            }
        });
        return new Rect(minLeft, minTop, maxRight - minLeft, maxBottom - minTop);
    }
    function calcRectByStartEndPoint(startPoint, endPoint, scrollX, scrollY) {
        if (scrollX === void 0) { scrollX = 0; }
        if (scrollY === void 0) { scrollY = 0; }
        var drawStartX = 0, drawStartY = 0;
        if (endPoint.x + scrollX >= startPoint.x &&
            endPoint.y + scrollY >= startPoint.y) {
            //4象限
            drawStartX = startPoint.x;
            drawStartY = startPoint.y;
            return new Rect(drawStartX - scrollX, drawStartY - scrollY, Math.abs(endPoint.x - startPoint.x + scrollX), Math.abs(endPoint.y - startPoint.y + scrollY));
        }
        else if (endPoint.x + scrollX < startPoint.x &&
            endPoint.y + scrollY < startPoint.y) {
            //1象限
            drawStartX = endPoint.x;
            drawStartY = endPoint.y;
            return new Rect(drawStartX, drawStartY, Math.abs(endPoint.x - startPoint.x + scrollX), Math.abs(endPoint.y - startPoint.y + scrollY));
        }
        else if (endPoint.x + scrollX < startPoint.x &&
            endPoint.y + scrollY >= startPoint.y) {
            //3象限
            drawStartX = endPoint.x;
            drawStartY = startPoint.y;
            return new Rect(drawStartX - scrollX, drawStartY - scrollY, Math.abs(endPoint.x - startPoint.x + scrollX), Math.abs(endPoint.y - startPoint.y + scrollY));
        }
        else {
            //2象限
            drawStartX = startPoint.x;
            drawStartY = endPoint.y;
            return new Rect(drawStartX, drawStartY, Math.abs(endPoint.x - startPoint.x + scrollX), Math.abs(endPoint.y - startPoint.y + scrollY));
        }
    }
    function calcEdgeLinesOfRect(rect) {
        return {
            v: [
                new LineSegment(new Point(rect.x, rect.y), new Point(rect.x, rect.y + rect.height)),
                new LineSegment(new Point(rect.x + rect.width / 2, rect.y), new Point(rect.x + rect.width / 2, rect.y + rect.height)),
                new LineSegment(new Point(rect.x + rect.width, rect.y), new Point(rect.x + rect.width, rect.y + rect.height)),
            ],
            h: [
                new LineSegment(new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y)),
                new LineSegment(new Point(rect.x, rect.y + rect.height / 2), new Point(rect.x + rect.width, rect.y + rect.height / 2)),
                new LineSegment(new Point(rect.x, rect.y + rect.height), new Point(rect.x + rect.width, rect.y + rect.height)),
            ],
        };
    }
    function calcRectOfAxisLineSegment(line) {
        if (!isLineSegment(line))
            return;
        var isXAxis = line.start.x === line.end.x;
        return new Rect(line.start.x, line.start.y, isXAxis ? 0 : line.end.x - line.start.x, isXAxis ? line.end.y - line.start.y : 0);
    }
    function calcSpaceBlockOfRect(target, source, type) {
        var targetRect = new Rect(target.x, target.y, target.width, target.height);
        var sourceRect = new Rect(source.x, source.y, source.width, source.height);
        if (sourceRect.bottom < targetRect.top && sourceRect.left > targetRect.right)
            return;
        if (sourceRect.top > targetRect.bottom && sourceRect.left > targetRect.right)
            return;
        if (sourceRect.bottom < targetRect.top && sourceRect.right < targetRect.left)
            return;
        if (sourceRect.top > targetRect.bottom && sourceRect.right < targetRect.left)
            return;
        if (sourceRect.bottom < targetRect.top) {
            var distance = targetRect.top - sourceRect.bottom;
            var left = Math.min(sourceRect.left, targetRect.left);
            var right = Math.max(sourceRect.right, targetRect.right);
            if (type && type !== 'top')
                return;
            return {
                type: 'top',
                distance: distance,
                rect: new Rect(left, sourceRect.bottom, right - left, distance),
            };
        }
        else if (sourceRect.top > targetRect.bottom) {
            var distance = sourceRect.top - targetRect.bottom;
            var left = Math.min(sourceRect.left, targetRect.left);
            var right = Math.max(sourceRect.right, targetRect.right);
            if (type && type !== 'bottom')
                return;
            return {
                type: 'bottom',
                distance: distance,
                rect: new Rect(left, targetRect.bottom, right - left, distance),
            };
        }
        else if (sourceRect.right < targetRect.left) {
            var distance = targetRect.left - sourceRect.right;
            var top_1 = Math.min(sourceRect.top, targetRect.top);
            var bottom = Math.max(sourceRect.bottom, targetRect.bottom);
            if (type && type !== 'left')
                return;
            return {
                type: 'left',
                distance: distance,
                rect: new Rect(sourceRect.right, top_1, distance, bottom - top_1),
            };
        }
        else if (sourceRect.left > targetRect.right) {
            var distance = sourceRect.left - targetRect.right;
            var top_2 = Math.min(sourceRect.top, targetRect.top);
            var bottom = Math.max(sourceRect.bottom, targetRect.bottom);
            if (type && type !== 'right')
                return;
            return {
                type: 'right',
                distance: distance,
                rect: new Rect(targetRect.right, top_2, distance, bottom - top_2),
            };
        }
    }
    function calcExtendsLineSegmentOfRect(targetRect, referRect) {
        if (referRect.right < targetRect.right &&
            targetRect.left <= referRect.right) {
            //右侧
            if (referRect.bottom < targetRect.top) {
                //上方
                return {
                    start: { x: referRect.right, y: referRect.bottom },
                    end: { x: targetRect.right, y: referRect.bottom },
                };
            }
            else if (referRect.top > targetRect.bottom) {
                //下方
                return {
                    start: { x: referRect.right, y: referRect.top },
                    end: { x: targetRect.right, y: referRect.top },
                };
            }
        }
        else if (referRect.left > targetRect.left &&
            targetRect.right >= referRect.left) {
            //左侧
            if (referRect.bottom < targetRect.top) {
                //上方
                return {
                    start: { x: targetRect.left, y: referRect.bottom },
                    end: { x: referRect.left, y: referRect.bottom },
                };
            }
            else if (referRect.top > targetRect.bottom) {
                //下方
                return {
                    start: { x: targetRect.left, y: referRect.top },
                    end: { x: referRect.left, y: referRect.top },
                };
            }
        }
        if (referRect.top < targetRect.top && targetRect.bottom >= referRect.top) {
            //refer在上方
            if (referRect.right < targetRect.left) {
                //右侧
                return {
                    start: { x: referRect.right, y: referRect.bottom },
                    end: { x: referRect.right, y: targetRect.bottom },
                };
            }
            else if (referRect.left > targetRect.right) {
                //左侧
                return {
                    start: { x: referRect.left, y: referRect.bottom },
                    end: { x: referRect.left, y: targetRect.bottom },
                };
            }
        }
        else if (referRect.bottom > targetRect.bottom &&
            referRect.top <= targetRect.bottom) {
            //refer下方
            if (referRect.right < targetRect.left) {
                //右侧
                return {
                    start: { x: referRect.right, y: targetRect.top },
                    end: { x: referRect.right, y: referRect.top },
                };
            }
            else if (referRect.left > targetRect.right) {
                //左侧
                return {
                    start: { x: referRect.left, y: targetRect.top },
                    end: { x: referRect.left, y: referRect.top },
                };
            }
        }
    }
    function calcOffsetOfSnapLineSegmentToEdge(line, current) {
        var edges = calcEdgeLinesOfRect(current);
        var isVerticalLine = line.start.x === line.end.x;
        if (isVerticalLine) {
            return { x: calcMinDistanceValue(edges.x, line.start.x) - current.x, y: 0 };
        }
        function calcEdgeLinesOfRect(rect) {
            return {
                x: [rect.x, rect.x + rect.width / 2, rect.x + rect.width],
                y: [rect.y, rect.y + rect.height / 2, rect.y + rect.height],
            };
        }
        function calcMinDistanceValue(edges, targetValue) {
            var minDistance = Infinity, minDistanceIndex = -1;
            for (var i = 0; i < edges.length; i++) {
                var distance = Math.abs(edges[i] - targetValue);
                if (minDistance > distance) {
                    minDistance = distance;
                    minDistanceIndex = i;
                }
            }
            return edges[minDistanceIndex];
        }
        return { x: 0, y: calcMinDistanceValue(edges.y, line.start.y) - current.y };
    }
    function calcDistanceOfSnapLineToEdges(line, edges) {
        var _a, _b, _c, _d;
        var distance = Infinity;
        if (((_a = line === null || line === void 0 ? void 0 : line.start) === null || _a === void 0 ? void 0 : _a.y) === ((_b = line === null || line === void 0 ? void 0 : line.end) === null || _b === void 0 ? void 0 : _b.y)) {
            edges.h.forEach(function (target) {
                var _distance = Math.abs(target.start.y - line.start.y);
                if (_distance < distance) {
                    distance = _distance;
                }
            });
        }
        else if (((_c = line === null || line === void 0 ? void 0 : line.start) === null || _c === void 0 ? void 0 : _c.x) === ((_d = line === null || line === void 0 ? void 0 : line.end) === null || _d === void 0 ? void 0 : _d.x)) {
            edges.v.forEach(function (target) {
                var _distance = Math.abs(target.start.x - line.start.x);
                if (_distance < distance) {
                    distance = _distance;
                }
            });
        }
        else {
            throw new Error('can not calculate slash distance');
        }
        return distance;
    }
    function calcCombineSnapLineSegment(target, source) {
        if (target.start.x === target.end.x) {
            return new LineSegment(new Point(target.start.x, target.start.y > source.start.y ? source.start.y : target.start.y), new Point(target.start.x, target.end.y > source.end.y ? target.end.y : source.end.y));
        }
        return new LineSegment(new Point(target.start.x > source.start.x ? source.start.x : target.start.x, target.start.y), new Point(target.end.x > source.end.x ? target.end.x : source.end.x, target.end.y));
    }
    function calcClosestEdges(line, edges) {
        var _a, _b, _c, _d;
        var result;
        var distance = Infinity;
        if (((_a = line === null || line === void 0 ? void 0 : line.start) === null || _a === void 0 ? void 0 : _a.y) === ((_b = line === null || line === void 0 ? void 0 : line.end) === null || _b === void 0 ? void 0 : _b.y)) {
            edges.h.forEach(function (target) {
                var _distance = Math.abs(target.start.y - line.start.y);
                if (_distance < distance) {
                    distance = _distance;
                    result = target;
                }
            });
        }
        else if (((_c = line === null || line === void 0 ? void 0 : line.start) === null || _c === void 0 ? void 0 : _c.x) === ((_d = line === null || line === void 0 ? void 0 : line.end) === null || _d === void 0 ? void 0 : _d.x)) {
            edges.v.forEach(function (target) {
                var _distance = Math.abs(target.start.x - line.start.x);
                if (_distance < distance) {
                    distance = _distance;
                    result = target;
                }
            });
        }
        else {
            throw new Error('can not calculate slash distance');
        }
        return [distance, result];
    }

    var IDX = 36, HEX = '';
    while (IDX--)
        HEX += IDX.toString(36);
    function uid(len) {
        var str = '', num = len || 11;
        while (num--)
            str += HEX[(Math.random() * 36) | 0];
        return str;
    }

    var instOf = function (value, cls) {
        if (isFn(cls))
            return value instanceof cls;
        if (isStr(cls))
            return globalThisPolyfill[cls]
                ? value instanceof globalThisPolyfill[cls]
                : false;
        return false;
    };

    var NATIVE_KEYS = [
        ['Map', function (map) { return new Map(map); }],
        ['WeakMap', function (map) { return new WeakMap(map); }],
        ['WeakSet', function (set) { return new WeakSet(set); }],
        ['Set', function (set) { return new Set(set); }],
        ['Date', function (date) { return new Date(date); }],
        'FileList',
        'File',
        'URL',
        'RegExp',
        [
            'Promise',
            function (promise) {
                return new Promise(function (resolve, reject) { return promise.then(resolve, reject); });
            },
        ],
    ];
    var isNativeObject = function (values) {
        for (var i = 0; i < NATIVE_KEYS.length; i++) {
            var item = NATIVE_KEYS[i];
            if (Array.isArray(item) && item[0]) {
                if (instOf(values, item[0])) {
                    return item[1] ? item[1] : item[0];
                }
            }
            else {
                if (instOf(values, item)) {
                    return item;
                }
            }
        }
    };
    var shallowClone = function (values) {
        var nativeClone;
        if (Array.isArray(values)) {
            return values.slice(0);
        }
        else if (isNativeObject(values)) {
            nativeClone = isNativeObject(values);
            return isFn(nativeClone) ? nativeClone(values) : values;
        }
        else if (typeof values === 'object' && !!values) {
            return __assign({}, values);
        }
    };
    var clone = function (values, filter) {
        var nativeClone;
        if (Array.isArray(values)) {
            return values.map(function (item) { return clone(item, filter); });
        }
        else if (isNativeObject(values)) {
            nativeClone = isNativeObject(values);
            return isFn(nativeClone) ? nativeClone(values) : values;
        }
        else if (typeof values === 'object' && !!values) {
            if ('$$typeof' in values && '_owner' in values) {
                return values;
            }
            if (values._isAMomentObject) {
                return values;
            }
            if (values._isJSONSchemaObject) {
                return values;
            }
            if (isFn(values.toJS)) {
                return values;
            }
            if (isFn(values.toJSON)) {
                return values;
            }
            if (Object.getOwnPropertySymbols(values || {}).length) {
                return values;
            }
            var res = {};
            for (var key in values) {
                if (Object.hasOwnProperty.call(values, key)) {
                    if (isFn(filter)) {
                        if (filter(values[key], key)) {
                            res[key] = clone(values[key], filter);
                        }
                        else {
                            res[key] = values[key];
                        }
                    }
                    else {
                        res[key] = clone(values[key], filter);
                    }
                }
            }
            return res;
        }
        else {
            return values;
        }
    };

    /**
     * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most
     * recently used items while discarding least recently used items when its limit
     * is reached.
     *
     * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>
     * See README.md for details.
     *
     * Illustration of the design:
     *
     *       entry             entry             entry             entry
     *       ______            ______            ______            ______
     *      | head |.newer => |      |.newer => |      |.newer => | tail |
     *      |  A   |          |  B   |          |  C   |          |  D   |
     *      |______| <= older.|______| <= older.|______| <= older.|______|
     *
     *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
     */
    /* eslint-disable */
    var NEWER = Symbol('newer');
    var OLDER = Symbol('older');
    function Entry(key, value) {
        this.key = key;
        this.value = value;
        this[NEWER] = undefined;
        this[OLDER] = undefined;
    }
    var LRUMap = /** @class */ (function () {
        function LRUMap(limit, entries) {
            if (typeof limit !== 'number') {
                // called as (entries)
                entries = limit;
                limit = 0;
            }
            this.size = 0;
            this.limit = limit;
            this.oldest = this.newest = undefined;
            this._keymap = new Map();
            if (entries) {
                this.assign(entries);
                if (limit < 1) {
                    this.limit = this.size;
                }
            }
        }
        LRUMap.prototype._markEntryAsUsed = function (entry) {
            if (entry === this.newest) {
                // Already the most recenlty used entry, so no need to update the list
                return;
            }
            // HEAD--------------TAIL
            //   <.older   .newer>
            //  <--- add direction --
            //   A  B  C  <D>  E
            if (entry[NEWER]) {
                if (entry === this.oldest) {
                    this.oldest = entry[NEWER];
                }
                entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.
            }
            if (entry[OLDER]) {
                entry[OLDER][NEWER] = entry[NEWER]; // C. --> E
            }
            entry[NEWER] = undefined; // D --x
            entry[OLDER] = this.newest; // D. --> E
            if (this.newest) {
                this.newest[NEWER] = entry; // E. <-- D
            }
            this.newest = entry;
        };
        LRUMap.prototype.assign = function (entries) {
            var entry;
            var limit = this.limit || Number.MAX_VALUE;
            this._keymap.clear();
            var it = entries[Symbol.iterator]();
            for (var itv = it.next(); !itv.done; itv = it.next()) {
                var e = new Entry(itv.value[0], itv.value[1]);
                this._keymap.set(e.key, e);
                if (!entry) {
                    this.oldest = e;
                }
                else {
                    entry[NEWER] = e;
                    e[OLDER] = entry;
                }
                entry = e;
                if (limit-- === 0) {
                    throw new Error('overflow');
                }
            }
            this.newest = entry;
            this.size = this._keymap.size;
        };
        LRUMap.prototype.get = function (key) {
            // First, find our cache entry
            var entry = this._keymap.get(key);
            if (!entry) {
                return;
            } // Not cached. Sorry.
            // As <key> was found in the cache, register it as being requested recently
            this._markEntryAsUsed(entry);
            return entry.value;
        };
        LRUMap.prototype.set = function (key, value) {
            var entry = this._keymap.get(key);
            if (entry) {
                // update existing
                entry.value = value;
                this._markEntryAsUsed(entry);
                return this;
            }
            // new entry
            this._keymap.set(key, (entry = new Entry(key, value)));
            if (this.newest) {
                // link previous tail to the new tail (entry)
                this.newest[NEWER] = entry;
                entry[OLDER] = this.newest;
            }
            else {
                // we're first in -- yay
                this.oldest = entry;
            }
            // add new entry to the end of the linked list -- it's now the freshest entry.
            this.newest = entry;
            ++this.size;
            if (this.size > this.limit) {
                // we hit the limit -- remove the head
                this.shift();
            }
            return this;
        };
        LRUMap.prototype.shift = function () {
            // todo: handle special case when limit == 1
            var entry = this.oldest;
            if (entry) {
                if (this.oldest[NEWER]) {
                    // advance the list
                    this.oldest = this.oldest[NEWER];
                    this.oldest[OLDER] = undefined;
                }
                else {
                    // the cache is exhausted
                    this.oldest = undefined;
                    this.newest = undefined;
                }
                // Remove last strong reference to <entry> and remove links from the purged
                // entry being returned:
                entry[NEWER] = entry[OLDER] = undefined;
                this._keymap.delete(entry.key);
                --this.size;
                return [entry.key, entry.value];
            }
        };
        LRUMap.prototype.find = function (key) {
            var e = this._keymap.get(key);
            return e ? e.value : undefined;
        };
        LRUMap.prototype.has = function (key) {
            return this._keymap.has(key);
        };
        LRUMap.prototype.delete = function (key) {
            var entry = this._keymap.get(key);
            if (!entry) {
                return;
            }
            this._keymap.delete(entry.key);
            if (entry[NEWER] && entry[OLDER]) {
                // relink the older entry with the newer entry
                entry[OLDER][NEWER] = entry[NEWER];
                entry[NEWER][OLDER] = entry[OLDER];
            }
            else if (entry[NEWER]) {
                // remove the link to us
                entry[NEWER][OLDER] = undefined;
                // link the newer entry to head
                this.oldest = entry[NEWER];
            }
            else if (entry[OLDER]) {
                // remove the link to us
                entry[OLDER][NEWER] = undefined;
                // link the newer entry to head
                this.newest = entry[OLDER];
            }
            else {
                // if(entry[OLDER] === undefined && entry.newer === undefined) {
                this.oldest = this.newest = undefined;
            }
            this.size--;
            return entry.value;
        };
        LRUMap.prototype.clear = function () {
            // Not clearing links should be safe, as we don't expose live links to user
            this.oldest = this.newest = undefined;
            this.size = 0;
            this._keymap.clear();
        };
        LRUMap.prototype.keys = function () {
            return new KeyIterator(this.oldest);
        };
        LRUMap.prototype.values = function () {
            return new ValueIterator(this.oldest);
        };
        LRUMap.prototype.entries = function () { };
        LRUMap.prototype.forEach = function (fun, thisObj) {
            if (typeof thisObj !== 'object') {
                thisObj = this;
            }
            var entry = this.oldest;
            while (entry) {
                fun.call(thisObj, entry.value, entry.key, this);
                entry = entry[NEWER];
            }
        };
        LRUMap.prototype.toJSON = function () {
            var s = new Array(this.size);
            var i = 0;
            var entry = this.oldest;
            while (entry) {
                s[i++] = { key: entry.key, value: entry.value };
                entry = entry[NEWER];
            }
            return s;
        };
        LRUMap.prototype.toString = function () {
            var s = '';
            var entry = this.oldest;
            while (entry) {
                s += String(entry.key) + ':' + entry.value;
                entry = entry[NEWER];
                if (entry) {
                    s += ' < ';
                }
            }
            return s;
        };
        LRUMap.prototype[Symbol.iterator] = function () {
            return new EntryIterator(this.oldest);
        };
        return LRUMap;
    }());
    var EntryIterator = /** @class */ (function () {
        function EntryIterator(oldestEntry) {
            this.entry = oldestEntry;
        }
        EntryIterator.prototype[Symbol.iterator] = function () {
            return this;
        };
        EntryIterator.prototype.next = function () {
            var ent = this.entry;
            if (ent) {
                this.entry = ent[NEWER];
                return { done: false, value: [ent.key, ent.value] };
            }
            else {
                return { done: true, value: undefined };
            }
        };
        return EntryIterator;
    }());
    var KeyIterator = /** @class */ (function () {
        function KeyIterator(oldestEntry) {
            this.entry = oldestEntry;
        }
        KeyIterator.prototype[Symbol.iterator] = function () {
            return this;
        };
        KeyIterator.prototype.next = function () {
            var ent = this.entry;
            if (ent) {
                this.entry = ent[NEWER];
                return { done: false, value: ent.key };
            }
            else {
                return { done: true, value: undefined };
            }
        };
        return KeyIterator;
    }());
    var ValueIterator = /** @class */ (function () {
        function ValueIterator(oldestEntry) {
            this.entry = oldestEntry;
        }
        ValueIterator.prototype[Symbol.iterator] = function () {
            return this;
        };
        ValueIterator.prototype.next = function () {
            var ent = this.entry;
            if (ent) {
                this.entry = ent[NEWER];
                return { done: false, value: ent.value };
            }
            else {
                return { done: true, value: undefined };
            }
        };
        return ValueIterator;
    }());

    var compose = function () {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return function (payload) {
            return fns.reduce(function (buf, fn) {
                return fn(buf);
            }, payload);
        };
    };

    var toArr = function (val) { return (isArr(val) ? val : val ? [val] : []); };
    function each(val, iterator, revert) {
        if (isArr(val) || isStr(val)) {
            if (revert) {
                for (var i = val.length - 1; i >= 0; i--) {
                    if (iterator(val[i], i) === false) {
                        return;
                    }
                }
            }
            else {
                for (var i = 0; i < val.length; i++) {
                    if (iterator(val[i], i) === false) {
                        return;
                    }
                }
            }
        }
        else if (isObj(val)) {
            var key = void 0;
            for (key in val) {
                if (Object.hasOwnProperty.call(val, key)) {
                    if (iterator(val[key], key) === false) {
                        return;
                    }
                }
            }
        }
    }
    function map(val, iterator, revert) {
        var res = isArr(val) || isStr(val) ? [] : {};
        each(val, function (item, key) {
            var value = iterator(item, key);
            if (isArr(res)) {
                res.push(value);
            }
            else {
                res[key] = value;
            }
        }, revert);
        return res;
    }
    function reduce(val, iterator, accumulator, revert) {
        var result = accumulator;
        each(val, function (item, key) {
            result = iterator(result, item, key);
        }, revert);
        return result;
    }
    function every(val, iterator, revert) {
        var res = true;
        each(val, function (item, key) {
            if (!iterator(item, key)) {
                res = false;
                return false;
            }
        }, revert);
        return res;
    }
    function some(val, iterator, revert) {
        var res = false;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = true;
                return false;
            }
        }, revert);
        return res;
    }
    function findIndex(val, iterator, revert) {
        var res = -1;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = key;
                return false;
            }
        }, revert);
        return res;
    }
    function find(val, iterator, revert) {
        var res;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = item;
                return false;
            }
        }, revert);
        return res;
    }
    function includes(val, searchElement, revert) {
        if (isStr(val))
            return val.includes(searchElement);
        return some(val, function (item) { return item === searchElement; }, revert);
    }
    function includesWith(val, search) {
        if (isArr(val)) {
            return val.some(function (item) { return search(item); });
        }
        else {
            return false;
        }
    }
    var flat = function (array) {
        return toArr(array).reduce(function (buf, item) {
            if (isArr(item))
                return buf.concat(flat(item));
            return buf.concat(item);
        }, []);
    };

    exports.KeyCode = void 0;
    (function (KeyCode) {
        KeyCode["Backspace"] = "Backspace";
        KeyCode["Tab"] = "Tab";
        KeyCode["Enter"] = "Enter";
        KeyCode["Shift"] = "Shift";
        KeyCode["Control"] = "Control";
        KeyCode["Alt"] = "Alt";
        KeyCode["CapsLock"] = "CapsLock";
        KeyCode["Escape"] = "Escape";
        KeyCode["Space"] = " ";
        KeyCode["PageUp"] = "PageUp";
        KeyCode["PageDown"] = "PageDown";
        KeyCode["End"] = "End";
        KeyCode["Home"] = "Home";
        KeyCode["ArrowLeft"] = "ArrowLeft";
        KeyCode["ArrowUp"] = "ArrowUp";
        KeyCode["ArrowRight"] = "ArrowRight";
        KeyCode["ArrowDown"] = "ArrowDown";
        KeyCode["Left"] = "Left";
        KeyCode["Up"] = "Up";
        KeyCode["Right"] = "Right";
        KeyCode["Down"] = "Down";
        KeyCode["Insert"] = "Insert";
        KeyCode["Delete"] = "Delete";
        KeyCode["Zero"] = "0";
        KeyCode["ClosedParen"] = ")";
        KeyCode["One"] = "1";
        KeyCode["ExclamationMark"] = "!";
        KeyCode["Two"] = "2";
        KeyCode["AtSign"] = "@";
        KeyCode["Three"] = "3";
        KeyCode["PoundSign"] = "\u00A3";
        KeyCode["Hash"] = "#";
        KeyCode["Four"] = "4";
        KeyCode["DollarSign"] = "$";
        KeyCode["Five"] = "5";
        KeyCode["PercentSign"] = "%";
        KeyCode["Six"] = "6";
        KeyCode["Caret"] = "^";
        KeyCode["Hat"] = "^";
        KeyCode["Seven"] = "7";
        KeyCode["Ampersand"] = "&";
        KeyCode["Eight"] = "8";
        KeyCode["Star"] = "*";
        KeyCode["Asterisk"] = "*";
        KeyCode["Nine"] = "9";
        KeyCode["OpenParen"] = "(";
        KeyCode["a"] = "a";
        KeyCode["b"] = "b";
        KeyCode["c"] = "c";
        KeyCode["d"] = "d";
        KeyCode["e"] = "e";
        KeyCode["f"] = "f";
        KeyCode["g"] = "g";
        KeyCode["h"] = "h";
        KeyCode["i"] = "i";
        KeyCode["j"] = "j";
        KeyCode["k"] = "k";
        KeyCode["l"] = "l";
        KeyCode["m"] = "m";
        KeyCode["n"] = "n";
        KeyCode["o"] = "o";
        KeyCode["p"] = "p";
        KeyCode["q"] = "q";
        KeyCode["r"] = "r";
        KeyCode["s"] = "s";
        KeyCode["t"] = "t";
        KeyCode["u"] = "u";
        KeyCode["v"] = "v";
        KeyCode["w"] = "w";
        KeyCode["x"] = "x";
        KeyCode["y"] = "y";
        KeyCode["z"] = "z";
        KeyCode["A"] = "A";
        KeyCode["B"] = "B";
        KeyCode["C"] = "C";
        KeyCode["D"] = "D";
        KeyCode["E"] = "E";
        KeyCode["F"] = "F";
        KeyCode["G"] = "G";
        KeyCode["H"] = "H";
        KeyCode["I"] = "I";
        KeyCode["J"] = "J";
        KeyCode["K"] = "K";
        KeyCode["L"] = "L";
        KeyCode["M"] = "M";
        KeyCode["N"] = "N";
        KeyCode["O"] = "O";
        KeyCode["P"] = "P";
        KeyCode["Q"] = "Q";
        KeyCode["R"] = "R";
        KeyCode["S"] = "S";
        KeyCode["T"] = "T";
        KeyCode["U"] = "U";
        KeyCode["V"] = "V";
        KeyCode["W"] = "W";
        KeyCode["X"] = "X";
        KeyCode["Y"] = "Y";
        KeyCode["Z"] = "Z";
        KeyCode["Meta"] = "Meta";
        KeyCode["LeftWindowKey"] = "Meta";
        KeyCode["RightWindowKey"] = "Meta";
        KeyCode["Numpad0"] = "0";
        KeyCode["Numpad1"] = "1";
        KeyCode["Numpad2"] = "2";
        KeyCode["Numpad3"] = "3";
        KeyCode["Numpad4"] = "4";
        KeyCode["Numpad5"] = "5";
        KeyCode["Numpad6"] = "6";
        KeyCode["Numpad7"] = "7";
        KeyCode["Numpad8"] = "8";
        KeyCode["Numpad9"] = "9";
        KeyCode["Multiply"] = "*";
        KeyCode["Add"] = "+";
        KeyCode["Subtract"] = "-";
        KeyCode["DecimalPoint"] = ".";
        KeyCode["MSDecimalPoint"] = "Decimal";
        KeyCode["Divide"] = "/";
        KeyCode["F1"] = "F1";
        KeyCode["F2"] = "F2";
        KeyCode["F3"] = "F3";
        KeyCode["F4"] = "F4";
        KeyCode["F5"] = "F5";
        KeyCode["F6"] = "F6";
        KeyCode["F7"] = "F7";
        KeyCode["F8"] = "F8";
        KeyCode["F9"] = "F9";
        KeyCode["F10"] = "F10";
        KeyCode["F11"] = "F11";
        KeyCode["F12"] = "F12";
        KeyCode["NumLock"] = "NumLock";
        KeyCode["ScrollLock"] = "ScrollLock";
        KeyCode["SemiColon"] = ";";
        KeyCode["Equals"] = "=";
        KeyCode["Comma"] = ",";
        KeyCode["Dash"] = "-";
        KeyCode["Period"] = ".";
        KeyCode["UnderScore"] = "_";
        KeyCode["PlusSign"] = "+";
        KeyCode["ForwardSlash"] = "/";
        KeyCode["Tilde"] = "~";
        KeyCode["GraveAccent"] = "`";
        KeyCode["OpenBracket"] = "[";
        KeyCode["ClosedBracket"] = "]";
        KeyCode["Quote"] = "'";
    })(exports.KeyCode || (exports.KeyCode = {}));
    var getKeyCodeFromEvent = function (event) {
        return event.key;
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    createCommonjsModule(function (module) {
    (function (factory) {
    	if (module.exports) {
    		module.exports = factory();
    	} else {
    		window.idleCallbackShim = factory();
    	}
    }(function(){
    	var scheduleStart, throttleDelay, lazytimer, lazyraf;
    	var root = typeof window != 'undefined' ?
    		window :
    		typeof commonjsGlobal != undefined ?
    			commonjsGlobal :
    			this || {};
    	var requestAnimationFrame = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;
    	var cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;
    	var tasks = [];
    	var runAttempts = 0;
    	var isRunning = false;
    	var remainingTime = 7;
    	var minThrottle = 35;
    	var throttle = 125;
    	var index = 0;
    	var taskStart = 0;
    	var tasklength = 0;
    	var IdleDeadline = {
    		get didTimeout(){
    			return false;
    		},
    		timeRemaining: function(){
    			var timeRemaining = remainingTime - (Date.now() - taskStart);
    			return timeRemaining < 0 ? 0 : timeRemaining;
    		},
    	};
    	var setInactive = debounce(function(){
    		remainingTime = 22;
    		throttle = 66;
    		minThrottle = 0;
    	});

    	function debounce(fn){
    		var id, timestamp;
    		var wait = 99;
    		var check = function(){
    			var last = (Date.now()) - timestamp;

    			if (last < wait) {
    				id = setTimeout(check, wait - last);
    			} else {
    				id = null;
    				fn();
    			}
    		};
    		return function(){
    			timestamp = Date.now();
    			if(!id){
    				id = setTimeout(check, wait);
    			}
    		};
    	}

    	function abortRunning(){
    		if(isRunning){
    			if(lazyraf){
    				cancelRequestAnimationFrame(lazyraf);
    			}
    			if(lazytimer){
    				clearTimeout(lazytimer);
    			}
    			isRunning = false;
    		}
    	}

    	function onInputorMutation(){
    		if(throttle != 125){
    			remainingTime = 7;
    			throttle = 125;
    			minThrottle = 35;

    			if(isRunning) {
    				abortRunning();
    				scheduleLazy();
    			}
    		}
    		setInactive();
    	}

    	function scheduleAfterRaf() {
    		lazyraf = null;
    		lazytimer = setTimeout(runTasks, 0);
    	}

    	function scheduleRaf(){
    		lazytimer = null;
    		requestAnimationFrame(scheduleAfterRaf);
    	}

    	function scheduleLazy(){

    		if(isRunning){return;}
    		throttleDelay = throttle - (Date.now() - taskStart);

    		scheduleStart = Date.now();

    		isRunning = true;

    		if(minThrottle && throttleDelay < minThrottle){
    			throttleDelay = minThrottle;
    		}

    		if(throttleDelay > 9){
    			lazytimer = setTimeout(scheduleRaf, throttleDelay);
    		} else {
    			throttleDelay = 0;
    			scheduleRaf();
    		}
    	}

    	function runTasks(){
    		var task, i, len;
    		var timeThreshold = remainingTime > 9 ?
    			9 :
    			1
    		;

    		taskStart = Date.now();
    		isRunning = false;

    		lazytimer = null;

    		if(runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart){
    			for(i = 0, len = tasks.length; i < len && IdleDeadline.timeRemaining() > timeThreshold; i++){
    				task = tasks.shift();
    				tasklength++;
    				if(task){
    					task(IdleDeadline);
    				}
    			}
    		}

    		if(tasks.length){
    			scheduleLazy();
    		} else {
    			runAttempts = 0;
    		}
    	}

    	function requestIdleCallbackShim(task){
    		index++;
    		tasks.push(task);
    		scheduleLazy();
    		return index;
    	}

    	function cancelIdleCallbackShim(id){
    		var index = id - 1 - tasklength;
    		if(tasks[index]){
    			tasks[index] = null;
    		}
    	}

    	if(!root.requestIdleCallback || !root.cancelIdleCallback){
    		root.requestIdleCallback = requestIdleCallbackShim;
    		root.cancelIdleCallback = cancelIdleCallbackShim;

    		if(root.document && document.addEventListener){
    			root.addEventListener('scroll', onInputorMutation, true);
    			root.addEventListener('resize', onInputorMutation);

    			document.addEventListener('focus', onInputorMutation, true);
    			document.addEventListener('mouseover', onInputorMutation, true);
    			['click', 'keypress', 'touchstart', 'mousedown'].forEach(function(name){
    				document.addEventListener(name, onInputorMutation, {capture: true, passive: true});
    			});

    			if(root.MutationObserver){
    				new MutationObserver( onInputorMutation ).observe( document.documentElement, {childList: true, subtree: true, attributes: true} );
    			}
    		}
    	} else {
    		try{
    			root.requestIdleCallback(function(){}, {timeout: 0});
    		} catch(e){
    			(function(rIC){
    				var timeRemainingProto, timeRemaining;
    				root.requestIdleCallback = function(fn, timeout){
    					if(timeout && typeof timeout.timeout == 'number'){
    						return rIC(fn, timeout.timeout);
    					}
    					return rIC(fn);
    				};
    				if(root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)){
    					timeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, 'timeRemaining');
    					if(!timeRemaining || !timeRemaining.configurable || !timeRemaining.get){return;}
    					Object.defineProperty(timeRemainingProto, 'timeRemaining', {
    						value:  function(){
    							return timeRemaining.get.call(this);
    						},
    						enumerable: true,
    						configurable: true,
    					});
    				}
    			})(root.requestIdleCallback);
    		}
    	}

    	return {
    		request: requestIdleCallbackShim,
    		cancel: cancelIdleCallbackShim,
    	};
    }));
    });

    var requestIdle = function (callback, options) {
        return globalThisPolyfill['requestIdleCallback'](callback, options);
    };
    var cancelIdle = function (id) {
        globalThisPolyfill['cancelIdleCallback'](id);
    };

    var InlineLayoutTagNames = new Set([
        'A',
        'ABBR',
        'ACRONYM',
        'AUDIO',
        'B',
        'BDI',
        'BDO',
        'BIG',
        'BR',
        'BUTTON',
        'CANVAS',
        'CITE',
        'CODE',
        'DATA',
        'DATALIST',
        'DEL',
        'DFN',
        'EM',
        'EMBED',
        'I',
        'IFRAME',
        'IMG',
        'INS',
        'KBD',
        'LABEL',
        'MAP',
        'MARK',
        'METER',
        'NOSCRIPT',
        'OBJECT',
        'OUTPUT',
        'PICTURE',
        'PROGRESS',
        'Q',
        'RUBY',
        'S',
        'SAMP',
        'SELECT',
        'SLOT',
        'SMALL',
        'STRONG',
        'SUB',
        'SUP',
        'SVG',
        'TEMPLATE',
        'TEXTAREA',
        'TIME',
        'U',
        'TT',
        'VAR',
        'VIDEO',
        'WBR',
        'INPUT',
        'SPAN',
    ]);
    var calcElementOuterWidth = function (innerWidth, style) {
        return (innerWidth +
            parseFloat(style.marginLeft) +
            parseFloat(style.marginRight) +
            parseFloat(style.paddingLeft) +
            parseFloat(style.paddingRight) +
            parseFloat(style.borderLeftWidth) +
            parseFloat(style.borderRightWidth));
    };
    var calcElementLayout = function (element) {
        if (!element)
            return 'vertical';
        var parent = element.parentElement;
        if (!parent)
            return 'vertical';
        var tagName = element.tagName;
        var parentTagName = parent.tagName;
        var style = getComputedStyle(element);
        var parentStyle = getComputedStyle(parent);
        var isNotFullWidth = function () {
            var innerWidth = element.getBoundingClientRect().width;
            var outerWidth = calcElementOuterWidth(innerWidth, style);
            var parentInnerWidth = parent.getBoundingClientRect().width;
            return outerWidth.toFixed(0) < parentInnerWidth.toFixed(0);
        };
        if (tagName === 'TH' || tagName === 'TD') {
            if (parentTagName === 'TR')
                return 'horizontal';
        }
        if (parentStyle.display === 'flex' && parentStyle.flexDirection === 'row')
            return 'horizontal';
        if (parentStyle.display === 'grid') {
            if (isNotFullWidth()) {
                return 'horizontal';
            }
        }
        if (InlineLayoutTagNames.has(tagName)) {
            if (style.display === 'block') {
                if (style.float === 'left' || style.float === 'right') {
                    if (isNotFullWidth()) {
                        return 'horizontal';
                    }
                }
                return 'vertical';
            }
            return 'horizontal';
        }
    };
    var calcElementTranslate = function (element) {
        var _a, _b, _c;
        var transform = (_a = element === null || element === void 0 ? void 0 : element.style) === null || _a === void 0 ? void 0 : _a.transform;
        if (transform) {
            var _d = __read((_c = (_b = transform
                .match(/translate(?:3d)?\(\s*([-\d.]+)[a-z]+?[\s,]+([-\d.]+)[a-z]+?(?:[\s,]+([-\d.]+))?[a-z]+?\s*\)/)) === null || _b === void 0 ? void 0 : _b.slice(1, 3)) !== null && _c !== void 0 ? _c : [0, 0], 2), x = _d[0], y = _d[1];
            return new Point(Number(x), Number(y));
        }
        else {
            return new Point(Number(element.offsetLeft), Number(element.offsetTop));
        }
    };
    var calcElementRotate = function (element) {
        var _a, _b, _c;
        var transform = (_a = element === null || element === void 0 ? void 0 : element.style) === null || _a === void 0 ? void 0 : _a.transform;
        if (transform) {
            return Number((_c = (_b = transform.match(/rotate\(\s*([-\d.]+)/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : 0);
        }
        else {
            return 0;
        }
    };
    var calcElementScale = function (element) {
        var _a, _b, _c;
        var transform = (_a = element === null || element === void 0 ? void 0 : element.style) === null || _a === void 0 ? void 0 : _a.transform;
        if (transform) {
            return Number((_c = (_b = transform.match(/scale\(\s*([-\d.]+)/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : 0);
        }
        else {
            return 0;
        }
    };

    var LayoutObserver = /** @class */ (function () {
        function LayoutObserver(observer) {
            if (observer === void 0) { observer = function () { }; }
            var _this = this;
            this.connected = false;
            this.observe = function (target) {
                _this.resizeObserver.observe(target);
                _this.performanceObserver.observe({
                    entryTypes: ['paint', 'element', 'layout-shift', 'event'],
                });
                _this.mutationObserver.observe(target, {
                    attributeFilter: ['style'],
                    attributes: true,
                });
                _this.connected = true;
            };
            this.disconnect = function () {
                if (_this.connected) {
                    _this.resizeObserver.disconnect();
                    _this.performanceObserver.disconnect();
                    _this.mutationObserver.disconnect();
                }
                _this.connected = false;
            };
            this.resizeObserver = new ResizeObserver(function () { return observer(); });
            this.performanceObserver = new PerformanceObserver(function () {
                observer();
            });
            this.mutationObserver = new MutationObserver(function () { return observer(); });
        }
        return LayoutObserver;
    }());

    exports.Event = Event;
    exports.EventDriver = EventDriver;
    exports.LRUMap = LRUMap;
    exports.LayoutObserver = LayoutObserver;
    exports.LineSegment = LineSegment;
    exports.Point = Point;
    exports.Rect = Rect;
    exports.Subscribable = Subscribable;
    exports.calcAutoScrollBasicInfo = calcAutoScrollBasicInfo;
    exports.calcBoundingRect = calcBoundingRect;
    exports.calcClosestEdges = calcClosestEdges;
    exports.calcCombineSnapLineSegment = calcCombineSnapLineSegment;
    exports.calcDistanceOfPointToRect = calcDistanceOfPointToRect;
    exports.calcDistanceOfSnapLineToEdges = calcDistanceOfSnapLineToEdges;
    exports.calcDistancePointToEdge = calcDistancePointToEdge;
    exports.calcEdgeLinesOfRect = calcEdgeLinesOfRect;
    exports.calcElementLayout = calcElementLayout;
    exports.calcElementOuterWidth = calcElementOuterWidth;
    exports.calcElementRotate = calcElementRotate;
    exports.calcElementScale = calcElementScale;
    exports.calcElementTranslate = calcElementTranslate;
    exports.calcExtendsLineSegmentOfRect = calcExtendsLineSegmentOfRect;
    exports.calcOffsetOfSnapLineSegmentToEdge = calcOffsetOfSnapLineSegmentToEdge;
    exports.calcQuadrantOfPointToRect = calcQuadrantOfPointToRect;
    exports.calcRectByStartEndPoint = calcRectByStartEndPoint;
    exports.calcRectOfAxisLineSegment = calcRectOfAxisLineSegment;
    exports.calcRelativeOfPointToRect = calcRelativeOfPointToRect;
    exports.calcSpaceBlockOfRect = calcSpaceBlockOfRect;
    exports.calcSpeedFactor = calcSpeedFactor;
    exports.cancelIdle = cancelIdle;
    exports.clone = clone;
    exports.compose = compose;
    exports.createUniformSpeedAnimation = createUniformSpeedAnimation;
    exports.each = each;
    exports.every = every;
    exports.find = find;
    exports.findIndex = findIndex;
    exports.flat = flat;
    exports.getKeyCodeFromEvent = getKeyCodeFromEvent;
    exports.getRectPoints = getRectPoints;
    exports.getType = getType;
    exports.globalThisPolyfill = globalThisPolyfill;
    exports.includes = includes;
    exports.includesWith = includesWith;
    exports.instOf = instOf;
    exports.isArr = isArr;
    exports.isBool = isBool;
    exports.isCrossRectInRect = isCrossRectInRect;
    exports.isEqualRect = isEqualRect;
    exports.isFn = isFn;
    exports.isHTMLElement = isHTMLElement;
    exports.isLineSegment = isLineSegment;
    exports.isNearAfter = isNearAfter;
    exports.isNum = isNum;
    exports.isObj = isObj;
    exports.isPlainObj = isPlainObj;
    exports.isPoint = isPoint;
    exports.isPointInRect = isPointInRect;
    exports.isRect = isRect;
    exports.isRectInRect = isRectInRect;
    exports.isRegExp = isRegExp;
    exports.isStr = isStr;
    exports.isValid = isValid;
    exports.isValidNumber = isValidNumber;
    exports.isWindow = isWindow;
    exports.map = map;
    exports.reduce = reduce;
    exports.requestIdle = requestIdle;
    exports.scrollAnimate = scrollAnimate;
    exports.shallowClone = shallowClone;
    exports.some = some;
    exports.toArr = toArr;
    exports.uid = uid;
    exports.updateScrollValue = updateScrollValue;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
